---
/**
 * BlogPostLayout.astro
 * Blog post detail page layout
 * Layout handles page framework, Components handle specific elements
 */
import DefaultLayout from '../base/DefaultLayout.astro';
import PostMeta from '../../components/blog/PostMeta.astro';
import PostHeader from '../../components/blog/PostHeader.astro';
import TableOfContents from '../../components/blog/TableOfContents.astro';
import PostFooter from '../../components/blog/PostFooter.astro';
import type { CollectionEntry } from 'astro:content';
import { currentMarkdownStyle } from '../../data/markdown-style.config';
import { generateMarkdownStyles } from '../../utils/markdown-style-generator';

interface Props {
  post: CollectionEntry<'blog'>;
  headings?: Array<{ depth: number; text: string; slug: string }>;
  readingTime?: string;
  readingMinutes?: number;
}

const { post, headings = [], readingTime, readingMinutes } = Astro.props;
const { title, description, publishDate, updatedDate, tags, cover, coverAlt, author, language } = post.data;

// Generate Markdown styles
const markdownStyles = generateMarkdownStyles(currentMarkdownStyle);
---

<DefaultLayout title={title} description={description}>
  <!-- Back button -->
  <div class="mb-6 mt-8">
    <button 
      id="back-button"
      class="inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm bg-[var(--md-sys-color-surface-variant)]/50 hover:bg-[var(--md-sys-color-surface-variant)] text-[var(--md-sys-color-on-surface-variant)] transition-all cursor-pointer border-none"
    >
      <i class="i-carbon:arrow-left"></i>
      Back
    </button>
  </div>

  <div class="blog-post-container flex gap-8 lg:gap-12 relative">
    <!-- Main content area -->
    <article class="blog-post flex-1 min-w-0">
      <!-- Post metadata -->
      <div class="mb-4">
        <PostMeta 
          publishDate={publishDate}
          updatedDate={updatedDate}
          readingMinutes={readingMinutes}
          language={language}
          tags={tags}
        />
      </div>
      
      <!-- Post title and description -->
      <PostHeader title={title} description={description} />
      
      <!-- Page views and comments (can be integrated with analytics later) -->
      <div class="post-stats text-sm text-[var(--md-sys-color-on-surface-variant)] mb-8">
        <span>1 views | 1 comments</span>
      </div>
      
      <!-- Post content -->
      <div class="post-content prose prose-lg max-w-none">
        <slot />
      </div>
      
      <!-- Post footer -->
      <PostFooter author={author} postUrl={Astro.url.href} />
    </article>
    
    <!-- Right sidebar TOC (desktop only) -->
    <TableOfContents headings={headings} />
  </div>
</DefaultLayout>

<style define:vars={{ markdownStyles }} is:global>
  /* Blog post container */
  .blog-post-container {
    max-width: 1400px;
    margin: 0 auto;
  }
</style>

<style is:global set:html={markdownStyles}></style>

<script>
  /**
   * Code block enhancement features
   * - Add copy button
   * - Add language label
   * - Add line numbers (if configured)
   */
  
  function enhanceCodeBlocks() {
    // Get all code blocks
    const codeBlocks = document.querySelectorAll('.prose pre');
    
    codeBlocks.forEach((pre) => {
      // Avoid duplicate processing
      if (pre.parentElement?.classList.contains('code-block-wrapper')) {
        return;
      }
      
      // Get code element and language info
      const codeElement = pre.querySelector('code');
      if (!codeElement) return;
      
      // Multiple ways to detect language
      let language = '';
      
      // Method 1: Check data-language attribute (most reliable)
      language = pre.getAttribute('data-language') || 
                 codeElement.getAttribute('data-language') || '';
      
      // Method 2: Extract language from class
      if (!language) {
        // Shiki/Astro typically uses one of these formats
        const patterns = [
          /language-(\w+)/,           // language-js
          /lang-(\w+)/,               // lang-js  
          /\blanguage:(\w+)/,         // language:js
          /^([a-z]+)$/,               // js (standalone language name)
        ];
        
        // Check code tag class
        const codeClasses = codeElement.className.split(/\s+/);
        for (const className of codeClasses) {
          for (const pattern of patterns) {
            const match = className.match(pattern);
            if (match && match[1]) {
              language = match[1];
              break;
            }
          }
          if (language) break;
        }
        
        // If not found yet, check pre tag
        if (!language) {
          const preClasses = (pre as HTMLElement).className.split(/\s+/);
          for (const className of preClasses) {
            for (const pattern of patterns) {
              const match = className.match(pattern);
              if (match && match[1]) {
                language = match[1];
                break;
              }
            }
            if (language) break;
          }
        }
      }
      
      // Method 3: Check Shiki-generated style attribute comments
      if (!language && codeElement.innerHTML.includes('shiki')) {
        // Shiki adds specific class names, try to extract from them
        const shikiMatch = codeElement.className.match(/shiki[^"]*\s+lang:(\w+)/);
        if (shikiMatch) {
          language = shikiMatch[1];
        }
      }
      
      // Default value
      if (!language) {
        language = 'plaintext';
      }
      
      // Create wrapper
      const wrapper = document.createElement('div');
      wrapper.className = 'code-block-wrapper';
      pre.parentNode?.insertBefore(wrapper, pre);
      wrapper.appendChild(pre);
      
      // Set language attribute (for CSS to display language label)
      pre.setAttribute('data-language', language);
      
      // Debug: output detected language
      console.log('Detected language:', language, 'for code block with classes:', codeElement.className, 'pre classes:', (pre as HTMLElement).className);
      
      // Create copy button
      const copyButton = document.createElement('button');
      copyButton.className = 'code-copy-button';
      copyButton.innerHTML = `
        <svg class="copy-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
        <svg class="check-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      `;
      copyButton.setAttribute('aria-label', 'Copy code to clipboard');
      copyButton.setAttribute('title', 'Copy');
      
      // Copy button click event
      copyButton.addEventListener('click', async () => {
        try {
          // Get plain text code (remove line numbers and decorations)
          const code = codeElement.textContent || '';
          await navigator.clipboard.writeText(code);
          
          // Update button state - show check icon
          const copyIcon = copyButton.querySelector('.copy-icon') as HTMLElement;
          const checkIcon = copyButton.querySelector('.check-icon') as HTMLElement;
          if (copyIcon && checkIcon) {
            copyIcon.style.display = 'none';
            checkIcon.style.display = 'block';
          }
          copyButton.classList.add('copied');
          copyButton.setAttribute('title', 'Copied!');
          
          // Restore after 2 seconds
          setTimeout(() => {
            if (copyIcon && checkIcon) {
              copyIcon.style.display = 'block';
              checkIcon.style.display = 'none';
            }
            copyButton.classList.remove('copied');
            copyButton.setAttribute('title', 'Copy');
          }, 2000);
        } catch (err) {
          console.error('Failed to copy code:', err);
        }
      });
      
      // Add copy button to wrapper
      wrapper.appendChild(copyButton);
    });
  }
  
  // Execute on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', enhanceCodeBlocks);
  } else {
    enhanceCodeBlocks();
  }
  
  // Support Astro View Transitions
  document.addEventListener('astro:page-load', enhanceCodeBlocks);
</script>

<script>
  /**
   * Task list interaction functionality
   * - Enable checkbox clicking
   * - Save state to localStorage (optional)
   */
  
  function enhanceTaskLists() {
    // Get all task list items
    const taskItems = document.querySelectorAll('.prose input[type="checkbox"]');
    
    taskItems.forEach((checkbox) => {
      const input = checkbox as HTMLInputElement;
      
      // Remove disabled attribute to make it interactive
      input.removeAttribute('disabled');
      
      // Get unique identifier for the article (for saving state)
      const articlePath = window.location.pathname;
      const taskListItem = input.closest('li');
      const taskText = taskListItem?.textContent?.trim() || '';
      const taskId = `task-${articlePath}-${taskText.substring(0, 50)}`;
      
      // Read previously saved state from localStorage
      const savedState = localStorage.getItem(taskId);
      if (savedState !== null) {
        input.checked = savedState === 'true';
      }
      
      // Add change event listener
      input.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        const isChecked = target.checked;
        
        // Save state to localStorage
        localStorage.setItem(taskId, isChecked.toString());
        
        // Optional: Add styles for completed tasks
        const listItem = target.closest('li');
        if (listItem) {
          if (isChecked) {
            listItem.classList.add('task-completed');
          } else {
            listItem.classList.remove('task-completed');
          }
        }
        
        // Optional: Add animation effect
        if (isChecked) {
          target.parentElement?.classList.add('task-check-animation');
          setTimeout(() => {
            target.parentElement?.classList.remove('task-check-animation');
          }, 300);
        }
      });
      
      // Initialize styling
      if (input.checked) {
        taskListItem?.classList.add('task-completed');
      }
    });
  }
  
  // Execute on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', enhanceTaskLists);
  } else {
    enhanceTaskLists();
  }
  
  // Support Astro View Transitions
  document.addEventListener('astro:page-load', enhanceTaskLists);
</script>

<script>
  /**
   * Back button functionality
   * Uses browser's history.back() to return to previous page
   */
  function initBackButton() {
    const backButton = document.getElementById('back-button');
    if (backButton) {
      backButton.addEventListener('click', () => {
        // If there's browser history, go back
        if (window.history.length > 1) {
          window.history.back();
        } else {
          // Otherwise return to blog list
          window.location.href = '/blog';
        }
      });
    }
  }

  // Execute on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initBackButton);
  } else {
    initBackButton();
  }

  // Support Astro View Transitions
  document.addEventListener('astro:page-load', initBackButton);
</script>

<script>
  /**
   * Save and restore scroll position
   * Auto-scroll to previous position when returning from article page
   */
  
  // Save current page scroll position
  function saveScrollPosition() {
    const scrollPosition = {
      x: window.scrollX,
      y: window.scrollY,
      path: window.location.pathname
    };
    sessionStorage.setItem('scrollPosition', JSON.stringify(scrollPosition));
  }

  // Restore scroll position
  function restoreScrollPosition() {
    const saved = sessionStorage.getItem('scrollPosition');
    if (saved) {
      try {
        const { x, y, path } = JSON.parse(saved);
        // Only restore scroll position for same path
        if (path === window.location.pathname) {
          // Use setTimeout to ensure page is fully loaded before scrolling
          setTimeout(() => {
            window.scrollTo(x, y);
            // Clear saved position after restoration
            sessionStorage.removeItem('scrollPosition');
          }, 100);
        }
      } catch (e) {
        console.error('Failed to restore scroll position:', e);
      }
    }
  }

  // Save scroll position on all link clicks
  function attachScrollSaveListeners() {
    document.querySelectorAll('a[href^="/blog/"]').forEach(link => {
      link.addEventListener('click', saveScrollPosition);
    });
  }

  // Restore scroll position on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      restoreScrollPosition();
      attachScrollSaveListeners();
    });
  } else {
    restoreScrollPosition();
    attachScrollSaveListeners();
  }

  // Support Astro View Transitions
  document.addEventListener('astro:page-load', () => {
    restoreScrollPosition();
    attachScrollSaveListeners();
  });

  // Save scroll position before page unload (as backup)
  window.addEventListener('beforeunload', saveScrollPosition);
</script>

<style>
  /* Responsive adjustments */
  @media (max-width: 1024px) {
    .blog-post-container {
      flex-direction: column;
    }
    
    .prose {
      font-size: 16px;
    }
    
    .prose h2::before {
      display: none;
    }
  }
  
  /* Selected text styling */
  .prose ::selection {
    background: var(--md-sys-color-primary-container);
    color: var(--md-sys-color-on-primary-container);
  }
  
  /* Print style optimization */
  @media print {
    .prose {
      font-size: 12pt;
      line-height: 1.6;
    }
    
    .prose a[href^="http"]::after {
      content: " (" attr(href) ")";
      font-size: 0.8em;
      color: #666;
    }
    
    .prose pre,
    .prose blockquote {
      page-break-inside: avoid;
    }
  }
</style>
